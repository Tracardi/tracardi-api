{"file_name": "docs/notations/logic_notation.md", "questions": ["What is the syntax of logic expression in Tracardi?"], "answer": "# Logic notation\nLogic notation is the way in which logical concepts and their interpretations are expressed in natural languages.\nTracardi uses logic notation in segment configuration, IF plugin action,or other conditional statements.\n\n## Syntax\n\nThe following grammar define logic expression syntax.\n\n```\nexpr:\n  | expr OR (expr AND expr)\n  | expr AND (expr OR expr)\n```\n\nthat means that expressions with similar operators e.g. OR must be in brackets.\n\n!!! Warning \"Remember...\"\n\n    The following conditional statement is forbidden:\n    \n    ```\n    field1=1 AND field2=2 OR field3=3\n    ```\n\n    correct statement is either:\n    \n    ```\n    field1=1 AND (field2=2 OR field3=3)\n    ```\n    \n    or\n    \n    ```\n    (field1=1 AND field2=2) OR field3=3\n    ```\n    \n    There is no auto resolution of priority operations\n\n## Condition resolution\n\nEach condition consist of a __field, operator, and value__. An operator is used to manipulate individual data items and\nreturn a result. Operators are represented by special characters or by keywords. List of operators is available below.\n\n``` title=\"Example\"\npayload@numberOfPurchases == 1\n```\n\nThis example will return __true__ if *numberOfPurchases* in payload equals 1. The data within our system is organized\ninto fields that are accessed using [dot notation](dot_notation.md). \n\n!!! Tip\n\n    Possible ways to access\n    data: ```payload@numberOfPurchases, payload@..., payload@numberOfPurchases.0, payload@numberOfPurchases[\"some key\"]```\n    For detailed instructions on how to access data using this notation, please refer to the \n    [dot notation](dot_notation.md) documentation.\n\nOperations can be joined by AND/OR.\n\n``` title=\"Example\"\npayload@numberOfPurchases == 1 AND payload@title == \"Title\"\n```\n\nThis example will return True if *numberOfPurchases* in payload equals 1 and *title* in payload equals \"Title\".\n\n## Operator order\n\nIf there is a data missing. For example:\n\n```\nprofile@missing.data == 1\n```\n\nthen you will see an error: Missing Value. To prevent it you will need to check if the data exists or is not empty. To\ndo so type:\n\n```\nprofile@missing.data NOT EMPTY AND profile@missing.data == 1\n```\n\nThis way when data does not exist or is empty then the rest of the condition will not be checked and the result will be\nFALSE. Otherwise, when the `profile@missing.data` exists and is equal 1 then the result is TRUE.\n\nThe order in the condition does mather.\n\n## Type of operators\n\nThere are other operators possible like:\n\n* less then (<)\n* greater then (>)\n* less or equal then (<=)\n* greater or equal then (>=)\n* not equal (!=)\n* exists (*field_name* EXISTS)\n* not exists (*field_name* NOT EXISTS)\n* empty (*field_name* EMPTY)\n* not empty (*field_name* NOT EMPTY)\n* consists (*field_name* CONSIST \"text\" )\n* starts with (*field_name* STARTS WITH \"text\" )\n* ends with (*field_name* ENDS WITH \"text\" )\n\n### Example of operator use\n\n``` title=\"Example\"\npayload@path.to.data NOT EMPTY\n```\n\n## Value types\n\nIn the example:\n\n``` title=\"Example\"\npayload@numberOfPurchases == 1 AND payload@title == \"Title\"\n```\n\nField *payload@numberOfPurchases* is considered an integer number while\n*payload@title* is considered a string.\n\n!!! Warning\n\n    Values of differnet types can not be compared. \n\n## Functions\n\nFunctions can be used to convert value, for example to certain types.\n\n* now() - returns current date and time\n* utcnow() - returns current UTC date and time\n* datetime(*field_name*) - returns *field_name* field content as date and time\n* now(*time_zone*) - returns current date and time with given *timezone* info\n* now.offset(*offset*) - returns current date and time with given offset (e.g. -15m)\n* now.timezone.offset(*timezone*, *offset*) - returns current date and time with given\n  *timezone* info with applied *offset*\n* datetime.offset(*field_name*, *offset*) - returns *field_name* field content as date and time with applied *offset*\n* datetime.timezone(*field_name*, *timezone*) - returns *field_name* field content "}