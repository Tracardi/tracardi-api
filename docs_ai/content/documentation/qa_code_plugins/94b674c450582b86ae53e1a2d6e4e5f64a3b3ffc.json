{"file_name": "docs/qa/code/plugins.md", "questions": ["Overall question: How can you write code for a Tracardi plugin?", "Specific questions:", "1. What is the purpose of writing code for a Tracardi plugin?", "2. How does a plugin act within the Tracardi workflow system?", "3. What are the main methods used in a Tracardi plugin and what are their purposes?"], "answer": "# Write some simple code of tracardi plugin\nThe purpose of writing code for a Tracardi plugin is to extend Tracardi's base functionalities by introducing new\nactions or nodes to the existing workflow. By creating plugins, we can add features or functionality that control and\nprocess the flow of data within Tracardi. These plugins can perform various tasks, such as data transformation, decision\nmaking based on data properties, communication with external resources, or any custom functionality required by the\nuser.\n\nEssentially, a plugin acts as an independent module within the Tracardi workflow system, representing a unit of work. A\nplugin would have an input, a program that processes this input, and an output. In addition, plugins also have a\nconfiguration that defines how they should behave, including information like how to connect to an external database.\n\nHere's an example of a simple plugin:\n\nThis is a Python class representing a Tracardi plugin. The FlowWalker plugin scans the execution flow and processes each\nnode accordingly.\n\n```python\nfrom tracardi.service.plugin.domain.register import Plugin, Spec, MetaData, Documentation, PortDoc\nfrom tracardi.service.plugin.runner import ActionRunner\nfrom tracardi.service.plugin.domain.result import Result\n\n\nclass FlowWalker(ActionRunner):\n\n    def __init__(self):\n        pass\n\n    async def set_up(self, config):\n        pass\n\n    async def run(self, payload: dict):\n        input_data = payload.get('input', {})\n        # process input_data here\n        processed_data = {\"output\": \"value\"}\n        return Result(port=\"payload\", value=processed_data)\n\n    async def close(self):\n        pass\n\n\ndef register() -> Plugin:\n    return Plugin(\n        start=False,\n        spec=Spec(\n            module=__name__,\n            className=FlowWalker.__name__,\n            inputs=[\"payload\"],\n            outputs=[\"payload\"],\n            version='0.7.1',\n            license=\"MIT\",\n            author=\"Author\"\n        ),\n        metadata=MetaData(\n            name='FlowWalker',\n            desc='Does nothing.',\n            icon='error',\n            group=[\"Events\"],\n            documentation=Documentation(\n                inputs={\n                    \"payload\": PortDoc(desc=\"This port takes payload object.\")\n                },\n                outputs={\n                    \"payload\": PortDoc(desc=\"This port returns given payload without any changes.\")\n                }\n            )\n        )\n    )\n\n```\n\nExplanation of the code:\n\n1. The `__init__` method initializes the plugin object. In this case, it does nothing.\n2. The `set_up` method is used to set up and initialize resources. In this case, it's empty because no setup is\n   required.\n3. The `run` method is the main method of the plugin that is triggered in the workflow. It takes an input dictionary,\n   processes it and returns the result. In this example, it simply reads the 'input' key from the dictionary, ignores\n   it, and returns a new dictionary with an 'output' key and 'value' value.\n4. The `close` method is used to close and clean up any resources. In this case it's empty because there are no\n   resources to close.\n5. `register` function registers delivers the information on how to register the plugin in the system.\n\nRemember that as a developer, you can customize all of these methods to perform whatever actions you want, based on the\nneeds of your project or workflow.", "hash": "94b674c450582b86ae53e1a2d6e4e5f64a3b3ffc"}