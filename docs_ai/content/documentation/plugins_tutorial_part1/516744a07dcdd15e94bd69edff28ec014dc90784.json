{"file_name": "docs/plugins/tutorial/part1.md", "questions": ["What is the life-cycle of a plugin in Tracardi?", "How to code a simple plugin in Tracardi?", "What is the purpose of the __init__() method in a plugin class?", "What is the purpose of the set_up() method in a plugin class?", "What is the purpose of the run() method in a plugin class?", "What is the purpose of the close() method in a plugin class?", "What is the purpose of the port in Tracardi?"], "answer": "# Part 1: Code simple plugin in Tracardi\nBeginner Programmer's Guide\n\nSo, you would like to know how to add a new item to a workflow in the Tracardi system.\nThis article describes how a python programmer can extend Tracardi with new functions with so-called plugins.\n\n## Introduction\n\nEvent handling in Tracardi is based on a __workflow__, which consists of individual __actions__ visualized as __nodes__\nin the workflow. Workflow control when each action/node should be triggered. The action consists of an __input__, __a\nprogram__ that computes the input data, and __an output__ (the result of the program computation). In tracardi, an action can have\none input and many outputs. In addition, the action has a configuration, it is a set of data that define how the program\nshould behave, Let's assume that we want to connect to external resources of some database, it is in the configuration\nthat we will have information about where this database is, and what username and password to use to connect to the\nresource.\n\nDue to the fact that Tracardi can have many outputs, we must somehow indicate on which output our data should appear.\nThat's why Tracardi introduces concepts such as a port. Thanks to them, we can indicate where the data will be returned.\nThe port that will not receive the data (returns the None value) causes that the workflow will not be performed in this\nbranch of the workflow.\n\n## Development environment\n\n!!! Info\n    To start working with the system, we need to prepare a development environment. Refer to the\n    [Python development environment](../../development/python_env.md) and read how\n    to do this.\n\n## Plugin life-cycle \n\nPlugins go through a life-cycle in which they are created, executed and recycled.\n\nWorkflow controls this process. When a workflow is created, the system recognizes which classes will be needed to start\nthe process defined in the data flow graph.\n\nThe process is as follows. The workflow checks what class is assigned to the node in the graph and checks if it exists.\nIt then creates its instances by running the parameterless `__init__` method of that class.\n\nIt then checks to see if there is an async set_up method. It passes the plug-in configuration to it. The configuration\nis stored inside the node and is defined during plug-in registration (more on that in a moment). Then the workflow\nexecutes nodes in the graph one by one and runs the `run(self, payload: dict, in_edge=None)` method, passing to it the\nparameters that appeared at the input to the node and the additional information on the connection from the previous\nnode.\n\nWhen the workflow exits, it executes the close method on each node.\n\nIn summary, we have the following methods in the plugin class.\n\n```python\n    __init__()  # (1)\n    async set_up(config)  # (2)\n    async run(input_payload)  # (3)\n    async close()  # (4)\n```\n\n1. Initializes the plugin object\n2. Set-ups the configuration and async resources\n3. Gets the input payload as dictionary and runs the plugin, also returns results on ports\n4. Closes async resources\n\n!!! Info\n    Please click (+) to see the comments for the code\n\n## Our first plugin\n\nWe already have all the information so let's try to write the first plugin.\n\nAll plugins inherit from the ActionRunner class. This class stores the internal state of the workflow, i.e. elements\nsuch as event data, profiles, etc. They can be useful for us while writing our plugin. Let's assume the simplest case,\nwe would like our workflow to react to the type of event that is sent to our system. It will check if the event is of\nthe type \"my-event\" and then it will return data from the input on the output named \"MyEvent\" otherwise it will return\nempty data on the port \"NotMyEvent\".\nOf-course we could use the built-in IF node, but we want to write our own.\n\n## Let\u2019s begin\n\nTheoretically, we should complete all the methods described above, but in our case not all are needed. We don't have\nconfiguration, so set_up method is not needed, we don't "}