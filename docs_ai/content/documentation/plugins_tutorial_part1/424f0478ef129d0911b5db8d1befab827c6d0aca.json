{"file_name": "docs/plugins/tutorial/part1.md", "questions": ["What is the process of creating a Tracardi plugin?"], "answer": "have connection to external systems, so close method is not\nneeded either, we don't have an internal state of class, so `__init__` will be empty.\n\nBefore we start, let's create a file in which we will write the code. The Tracardi plugins are in the directory:\n`/tracardi/process_engine/action/v1`. You can create your own catalog there or use an existing one. I will create\nmy_plugin_folder directory and put my_plugin.py file in it.\n\n### Now the code.\n\nOur plugin could look like this:\n\n=== \"/tracardi/process_engine/action/v1/my_plugin_folder/my_plugin.py\"\n\n    ```python\n    from tracardi.service.plugin.runner import ActionRunner\n    from tracardi.service.plugin.domain.result import Result\n    \n    class MyPlugin(ActionRunner):  # (1)\n        async def run(self, payload: dict, in_edge=None):  # (2)\n            if self.event.type == \"my-event\":\n                return Result(port=\"MyEvent\", value=payload)  # (3)\n            else:\n                return Result(port=\"NotMyEvent\", value={})  # (4)\n    ```\n\n    1. Extends ActionRunner class\n    2. Runs the plugin\n    3. Returns the input payload data on the \"MyEvent\" port \n    4. Returns the empty dictionary on the \"NotMyEvent\" port \n\nNote that we return the data using the `Result` class in which we provide the port name and value.\n\nThe only thing left for us to do is to describe the plugin in the system. This is done by defining a function called\n`register`. It contains the specification of the plugin that we wrote (it returns the plugin class) and the type\nmetadata, with the input and output ports, the name of the plugin, etc.\n\nThe register function can be placed in the same file as the plugin or in any other file. I am placing it in the same\nfile.\n\n#### Example:\n\n=== \"/tracardi/process_engine/action/v1/my_plugin_folder/my_plugin.py\"\n\n    ```python\n    from tracardi.service.plugin.domain.register import Plugin, Spec, MetaData\n\n    def register() -> Plugin:\n        return Plugin(   # (1)\n            start=False,\n            spec=Spec(  # (2)\n                module=__name__,  # (4)\n                className=MyPlugin.__name__,\n                inputs=[\"payload\"],\n                outputs=[\"MyEvent\", \"NotMyEvent\"],\n                version='0.1',\n                license=\"MIT\",\n                author=\"Your Name\"\n            ),\n            metadata=MetaData(  # (3)\n                name=\"My first plugin\",\n                desc='Checks if the event type is equal to my-event.',\n                group=[\"Test plugin\"]\n            )\n        )\n    ```\n\n    1. Returns Plugin class\n    2. Sets spec property as Spec class\n    3. Sets metadata property as Metadata class\n    4. Sets `__name__` because refister is in the same file as plugin: e.i. `/tracardi/process_engine/action/v1/my_plugin_folder/my_plugin.py`\n\nLet's analyze this code. It returns a plugin class that has the following properties.\n\n* __start__ - sets whether the workflow can start from this node. In 99% of cases, we put `False` here. The startup\n  nodes are already built into the system.\n* __spec__ - describes the plugin specification, i.e. what class is to be run and what ports it contains on input and\n  output. There can only be one port on input. In our case, we have the following data:\n    * __module__ - where is the class package. `__name__` means that the class is in the same file as the register\n      method.\n      If we separate the plugin and register function, then you need to enter the package name of the plugin here, e.g.\n      `tracardi.process_engine.action.v1.my_plugin_folder`\n    * __className__ - the name of the class. We named it MyPlugin. See class `MyPlugin (ActionRunner)`\n    * __inputs__ - list with the names of the input ports. There can only be one input port.\n    * __outputs__ - list with names of output ports. Here we define what ports we have. Port names can have any name you\n      like. Remember, however, that they must correspond to what the code returns and our code returns, one\n      time: `Result (port=\"MyEven"}