# Your task

You have been assigned the task of documenting the Tracardi code.

Your goal is to create clear and understandable documentation for non-technical individuals who may not be familiar with
terms like variable or class. You will be provided with the plugin's code and an available manual (if available), which
you should incorporate into a single, consistent documentation in Markdown format.

The documentation should begin with the plain Short description of the code. Do not use word plugin or code, rather use Tracardi or system.

Use only plain English to describe the code and its flow. Avoid including any code in the
documentation, except where necessary for clarity. Use the logic from the code to describe its purpose and how it works. 

Include information about returned exceptions and errors and the condition when they may occur. Document it in `Errors`
section with all the exceptions (meaning exception message) and the condition when they may occur. 

Describe what the code does. In detail describe the whole flow of logic. Use code comments to make documentation easy to understand. 
Name this documentation "How tracardi gets profile geo location"

# General context

* Tracardi is a Customer Data Platform that collects information about customers.
* Data in Tracardi is represented as events, which are recognized actions or occurrences.
* Each event is assigned to a profile that remains consistent throughout customer interactions.
* Tracardi utilizes a graphical editor to aggregate customer journey data into profiles.
* Customer consents can be utilized within Tracardi.
* Tracardi enhances customer engagement through micro frontend applications, such as website pop-ups for collecting customer answers.
* Tracardi does not support marketing campaigns.
* The data processing library in Tracardi handles workflows and enables plugin development.
* Tracardi provides a graphical interface for creating, editing, and managing workflows.
* Workflows consist of nodes representing actions.
* Parameters can be configured to customize the behavior of each action node in a workflow.
* Workflows are executed in response to events.
* Tracardi receives incoming traffic, which includes data from websites and internal systems.
* Outgoing traffic from Tracardi is sent to external systems or destinations.
* Bridges collect data from specific sources (e.g., queue, email, social media).
* Event sources in Tracardi are identified by unique identifiers generated by the system.
* Event sources require bridges for data transfer.
* Event sources can be set as ephemeral, where data is processed but not permanently stored.
* Resources in Tracardi are sets of authentication credentials (e.g., passwords, tokens) for accessing external systems and databases.
* Sessions in Tracardi are associated with visits to websites or applications.
* Sessions contain context information about the events' context.
* Events in Tracardi represent actions occurring at specific times.
* Events track visitor behavior, such as clicks, logins, and page views.
* Events can capture additional data related to the event.
* Tracardi stores events and passes them to workflows for processing.
* Routing rules determine which workflows to execute based on event arrival.
* Routing rules automate workflow execution based on specific events.
* Routing rules consist of event type, event source, and the associated workflow.
* Workflows in Tracardi are a series of actions executed in response to events.
* Workflows are represented as graphs of nodes.
* Actions within workflows are assigned to individual nodes.
* Workflows run only if the event type is routed to them through routing rules.
* Actions are individual tasks performed within workflows, also known as workflow plugins.
* Actions receive data through input ports and send data through output ports.
* Actions can be extended using custom code written by programmers.
* Profiles in Tracardi are detailed records or representations of individuals or entities.
* Profiles contain information about characteristics, interests, and activities.
* Profiles are updated based on incoming events and data from external systems.
* Segment is a group of customer profiles based on shared characteristics or behavior.
* Destination is an external system where profile data is sent from Tracardi.
* Customer consent is a permission obtained from individuals to collect, use, or share their personal data.
* Data compliance is adherence to laws, regulations, and guidelines for handling data.
* Identification point is a feature allowing the system to identify customers during their journey.
* User/Customer is anonymous until the identification point is reached.
* Identification point enables merging of previous interactions/events with the identified profile.
* Tracardi can be integrated with mobile apps or external systems.

# Documentation template

Use this template to generate the documentation:


```markdown
# <Put here the title of documentation>

<Put here short description inferred from the code.></Put>

## Description

<Put here verbose description of the code. Use the logic from the code to describe how the code works. Describe it setp by step.> 


# Errors

<Put here all possible errors. Put here Exception message (not exception type) that means if there is ` raise ValueError("Profile event sequencing can not be performed without profile. Is this a profile less event?")` "Profile event sequencing can not be performed without profile. Is this a profile less event?" not `ValueError`.
and after the error the description when it may occur.>

```

---
Here is the full code:

# Is new session
        if session.operation.new:

            # Add session created event to the registered events
            tracker_payload.events.append(
                EventPayload(type='session-opened', properties={})
            )

            # Compute the User Agent data
            try:
                ua_string = session.context['browser']['local']['browser']['userAgent']
                user_agent = parse(ua_string)

                session.os.version = user_agent.os.version_string
                session.os.name = user_agent.os.family

                device_type = 'mobile' if user_agent.is_mobile else \
                    'pc' if user_agent.is_pc else \
                        'tablet' if user_agent.is_tablet else \
                            'email' if user_agent.is_email_client else None

                if 'device' in session.context:
                    session.device.name = session.context['device'].get('name', user_agent.device.family)
                    session.device.brand = session.context['device'].get('brand', user_agent.device.brand)
                    session.device.model = session.context['device'].get('model', user_agent.device.model)
                    session.device.touch = session.context['device'].get('model', user_agent.device.is_touch_capable)
                    session.device.type = session.context['device'].get('type', device_type)
                else:
                    session.device.name = user_agent.device.family
                    session.device.brand = user_agent.device.brand
                    session.device.model = user_agent.device.model
                    session.device.touch = user_agent.is_touch_capable
                    session.device.type = device_type

                # Get Language from request and geo

                spoken_languages = []
                language_codes = []
                if 'headers' in tracker_payload.request and 'accept-language' in tracker_payload.request['headers']:
                    languages = parse_accept_language(tracker_payload.request['headers']['accept-language'])
                    if languages:
                        spoken_lang_codes = [language for (language, _) in languages if len(language) == 2]
                        for lang_code in spoken_lang_codes:
                            if lang_code in language_codes_dict:
                                spoken_languages += language_codes_dict[lang_code]
                                language_codes.append(lang_code)

                if session.device.geo.country.code:
                    lang_code = session.device.geo.country.code.lower()
                    if lang_code in language_codes_dict:
                        spoken_languages += language_codes_dict[lang_code]
                        language_codes.append(lang_code)

                if spoken_languages:
                    session.context['language'] = list(set(spoken_languages))
                    profile.data.pii.language.spoken = session.context['language']

                if 'geo' not in profile.aux:
                    profile.aux['geo'] = {}

                # Continent

                if 'time' in tracker_payload.context:
                    tz = tracker_payload.context['time'].get('tz', 'utc')

                    if tz.lower() != 'utc':
                        continent = tz.split('/')[0]
                    else:
                        continent = 'n/a'

                    profile.aux['geo']['continent'] = continent

                # Aux markets

                markets = []
                for lang_code in language_codes:
                    if lang_code in language_countries_dict:
                        markets += language_countries_dict[lang_code]

                if markets:
                    profile.aux['geo']['markets'] = markets

                # Screen

                try:
                    session.device.resolution = f"{tracker_payload.context['screen']['local']['width']}x{tracker_payload.context['screen']['local']['height']}"
                except KeyError:
                    pass

                try:
                    session.device.color_depth = int(tracker_payload.context['screen']['local']['colorDepth'])
                except KeyError:
                    pass

                try:
                    session.device.orientation = tracker_payload.context['screen']['local']['orientation']
                except KeyError:
                    pass

                session.app.bot = user_agent.is_bot
                session.app.name = user_agent.browser.family  # returns 'Mobile Safari'
                session.app.version = user_agent.browser.version_string
                session.app.type = "browser"

                if 'utm' in tracker_payload.context:
                    try:
                        session.utm = UTM(**tracker_payload.context['utm'])
                        del tracker_payload.context['utm']
                    except ValidationError:
                        pass

                # session.app.resolution = session.context['screen']

            except Exception as e:
                pass

            try:
                session.device.ip = tracker_payload.request['headers']['x-forwarded-for']
            except Exception:
                pass

            try:
                session.app.language = session.context['browser']['local']['browser']['language']
            except Exception:
                pass

        # Updates on EXISTING Session

        if 'location' in tracker_payload.context:

            try:
                _geo = Geo(**tracker_payload.context['location'])

                del tracker_payload.context['location']

                # If location is sent but not available in session - update session

                if session.device.geo.is_empty():
                    session.device.geo = _geo
                    session.operation.update = True

                # Add last geo to profile
                if profile.data.devices.last.geo.is_empty() or _geo != profile.data.devices.last.geo:
                    profile.data.devices.last.geo = _geo
                    profile.operation.update = True

            except ValidationError as e:
                logger.error(str(e))

        # Still no geo location, bu twe have IP
        if session.device.ip:

            # Check if no MAXMIND_API_KEY
            maxmind_license_key = os.environ.get('MAXMIND_LICENSE_KEY', None)
            maxmind_account_id = int(os.environ.get('MAXMIND_ACCOUNT_ID', 0))
            if maxmind_license_key and maxmind_account_id > 0:

                if profile.data.devices.last.geo.is_empty():
                    # If last geo of a profile is empty

                    _geo = await get_geo_location(GeoLiteCredentials(
                        license=maxmind_license_key,
                        accountId=maxmind_account_id), ip=session.device.ip)

                    profile.data.devices.last.geo = _geo
                    profile.operation.update = True

                elif session.operation.new:

                    logger.info(f"Fetching GEO location for {session.device.ip}")

                    try:
                        _geo = await get_geo_location(GeoLiteCredentials(
                            license=maxmind_license_key,
                            accountId=maxmind_account_id), ip=session.device.ip)

                        session.device.geo = _geo

                        if profile.data.devices.last.geo.is_empty() or _geo != profile.data.devices.last.geo:
                            profile.data.devices.last.geo = _geo
                            profile.operation.update = True

                    except Exception as e:
                        logger.error(f"Could not fetch GEO location. Error: {str(e)}")
